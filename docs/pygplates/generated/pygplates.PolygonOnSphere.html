<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pygplates.PolygonOnSphere &mdash; pygplates 2.1.0.18 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.1.0.18',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pygplates 2.1.0.18 documentation" href="../index.html" />
    <link rel="up" title="Reference" href="../pygplates_reference.html" />
    <link rel="next" title="pygplates.GeometryOnSphere" href="pygplates.GeometryOnSphere.html" />
    <link rel="prev" title="pygplates.PolylineOnSphere" href="pygplates.PolylineOnSphere.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="pygplates.GeometryOnSphere.html" title="pygplates.GeometryOnSphere"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pygplates.PolylineOnSphere.html" title="pygplates.PolylineOnSphere"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pygplates 2.1.0.18 documentation</a> &raquo;</li>
          <li><a href="../pygplates_reference.html" accesskey="U">Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pygplates-polygononsphere">
<h1>pygplates.PolygonOnSphere<a class="headerlink" href="#pygplates-polygononsphere" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pygplates.PolygonOnSphere">
<em class="property">class </em><tt class="descclassname">pygplates.</tt><tt class="descname">PolygonOnSphere</tt><big>(</big><em>...</em><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">pygplates.GeometryOnSphere</span></tt></a></p>
<p>Represents a polygon on the surface of the unit length sphere. Polygons are equality (<tt class="docutils literal"><span class="pre">==</span></tt>, <tt class="docutils literal"><span class="pre">!=</span></tt>) comparable (but not hashable - cannot be used as a key in a <tt class="docutils literal"><span class="pre">dict</span></tt>). See <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a> for an overview of equality in the presence of limited floating-point precision.</p>
<p>A polygon instance is both:</p>
<ul class="simple">
<li>a sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">points</span></tt></a> - see <a class="reference internal" href="#pygplates.PolygonOnSphere.get_points" title="pygplates.PolygonOnSphere.get_points"><tt class="xref py py-meth docutils literal"><span class="pre">get_points()</span></tt></a>, and</li>
<li>a sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">segments</span></tt></a> (between adjacent points) - see <a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><tt class="xref py py-meth docutils literal"><span class="pre">get_segments()</span></tt></a>.</li>
</ul>
<p>In addition a polygon instance is <em>directly</em> iterable over its points (without having to use <a class="reference internal" href="#pygplates.PolygonOnSphere.get_points" title="pygplates.PolygonOnSphere.get_points"><tt class="xref py py-meth docutils literal"><span class="pre">get_points()</span></tt></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">polygon</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>...and so the following operations for accessing the points are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Operation</th>
<th class="head">Result</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">len(polygon)</span></tt></td>
<td>number of vertices in <em>polygon</em></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">polygon</span></tt></td>
<td>iterates over the vertices <em>p</em> of <em>polygon</em></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">p</span> <span class="pre">in</span> <span class="pre">polygon</span></tt></td>
<td><tt class="docutils literal"><span class="pre">True</span></tt> if <em>p</em> is equal to a <strong>vertex</strong> of <em>polygon</em></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">p</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">polygon</span></tt></td>
<td><tt class="docutils literal"><span class="pre">False</span></tt> if <em>p</em> is equal to a <strong>vertex</strong> of <em>polygon</em></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">polygon[i]</span></tt></td>
<td>the vertex of <em>polygon</em> at index <em>i</em></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">polygon[i:j]</span></tt></td>
<td>slice of <em>polygon</em> from <em>i</em> to <em>j</em></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">polygon[i:j:k]</span></tt></td>
<td>slice of <em>polygon</em> from <em>i</em> to <em>j</em> with step <em>k</em></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">if</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">polygon</span></tt> does <strong>not</strong> test whether a point <tt class="docutils literal"><span class="pre">p</span></tt> is <em>inside</em> the the <em>interior</em> of a polygon - use <a class="reference internal" href="#pygplates.PolygonOnSphere.is_point_in_polygon" title="pygplates.PolygonOnSphere.is_point_in_polygon"><tt class="xref py py-meth docutils literal"><span class="pre">is_point_in_polygon()</span></tt></a> for that instead.</p>
</div>
<div class="line-block">
<div class="line">Since a <em>PolygonOnSphere</em> is <strong>immutable</strong> it contains no operations or methods that modify its state (such as adding or removing points). This is similar to other immutable types in python such as <tt class="docutils literal"><span class="pre">str</span></tt>.</div>
<div class="line">So instead of modifying an existing polygon you will need to create a new <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a> instance as the following example demonstrates:</div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Get a list of points from an existing &#39;polygon&#39;.</span>
<span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

<span class="c1"># Modify the points list somehow.</span>
<span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>

<span class="c1"># &#39;polygon&#39; now references a new PolygonOnSphere instance.</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
</pre></div>
</div>
<p>The following example demonstrates creating a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a> from a <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">polyline</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A polygon closes the loop between its last and first points so there&#8217;s no need to make the first and last points equal.</p>
</div>
<dl class="method">
<dt id="pygplates.PolygonOnSphere.__init__">
<tt class="descname">__init__</tt><big>(</big><em>...</em><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A <em>PolygonOnSphere</em> object can be constructed in more than one way...</p>
<dl class="docutils">
<dt>__init__(points)</dt>
<dd><p class="first">Create a polygon from a sequence of (x,y,z) or (latitude,longitude) points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param points:</th><td class="field-body">A sequence of (x,y,z) points, or (latitude,longitude) points (in degrees).</td>
</tr>
<tr class="field-even field"><th class="field-name">type points:</th><td class="field-body">Any sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><tt class="xref py py-class docutils literal"><span class="pre">LatLonPoint</span></tt></a> or tuple (float,float,float) or tuple (float,float)</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body">InvalidLatLonError if any <em>latitude</em> or <em>longitude</em> is invalid</td>
</tr>
<tr class="field-even field"><th class="field-name">raises:</th><td class="field-body">ViolatedUnitVectorInvariantError if any (x,y,z) is not unit magnitude</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body">InvalidPointsForPolygonConstructionError if sequence has less than three points or if any two points (adjacent in the <em>points</em> sequence) are antipodal to each other (on opposite sides of the globe)</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The sequence must contain at least three points in order to be a valid polygon, otherwise <em>InvalidPointsForPolygonConstructionError</em> will be raised.</p>
</div>
<p>During creation, a <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">GreatCircleArc</span></tt></a> is created between each adjacent pair of of points in <em>points</em> - see <a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><tt class="xref py py-meth docutils literal"><span class="pre">get_segments()</span></tt></a>. The last arc is created between the last and first points to close the loop of the polygon. For this reason you do <em>not</em> need to ensure that the first and last points have the same position (although it&#8217;s not an error if this is the case because the final arc will then just have a zero length).</p>
<p>It is <em>not</em> an error for adjacent points in the sequence to be coincident. In this case each <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">GreatCircleArc</span></tt></a> between two such adjacent points will have zero length (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.is_zero_length" title="pygplates.GreatCircleArc.is_zero_length"><tt class="xref py py-meth docutils literal"><span class="pre">GreatCircleArc.is_zero_length()</span></tt></a> will return <tt class="docutils literal"><span class="pre">True</span></tt>) and will have no rotation axis (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.get_rotation_axis" title="pygplates.GreatCircleArc.get_rotation_axis"><tt class="xref py py-meth docutils literal"><span class="pre">GreatCircleArc.get_rotation_axis()</span></tt></a> will raise an error).</p>
<p>The following example shows a few different ways to create a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">polygon</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon1</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat2</span><span class="p">,</span><span class="n">lon2</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat3</span><span class="p">,</span><span class="n">lon3</span><span class="p">))</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">z1</span><span class="p">])</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z2</span><span class="p">])</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x3</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">z3</span><span class="p">])</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
</pre></div>
</div>
<p>If you have latitude/longitude values but they are not a sequence of tuples or if the latitude/longitude order is swapped then the following examples demonstrate how you could restructure them:</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Flat lat/lon array.</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat3</span><span class="p">,</span> <span class="n">lon3</span><span class="p">])</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>

<span class="c1"># Flat lon/lat list (ie, different latitude/longitude order).</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon3</span><span class="p">,</span> <span class="n">lat3</span><span class="p">]</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span><span class="n">points</span><span class="p">[::</span><span class="mi">2</span><span class="p">]))</span>

<span class="c1"># Separate lat/lon arrays.</span>
<span class="n">lats</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lat3</span><span class="p">])</span>
<span class="n">lons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lon3</span><span class="p">])</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span><span class="n">lons</span><span class="p">))</span>

<span class="c1"># Lon/lat list of tuples (ie, different latitude/longitude order).</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">),</span> <span class="p">(</span><span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">),</span> <span class="p">(</span><span class="n">lon3</span><span class="p">,</span> <span class="n">lat3</span><span class="p">)]</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">([(</span><span class="n">lat</span><span class="p">,</span><span class="n">lon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>
</pre></div>
</div>
</dd>
<dt>__init__(geometry, [allow_one_or_two_points=True])</dt>
<dd><p class="first">Create a polygon from a <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">GeometryOnSphere</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param geometry:</th><td class="field-body">The point, multi-point, polyline or polygon geometry to convert from.</td>
</tr>
<tr class="field-even field"><th class="field-name">type geometry:</th><td class="field-body"><a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">GeometryOnSphere</span></tt></a></td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param allow_one_or_two_points:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Whether <em>geometry</em> is allowed to be a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a> or a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a> containing only one or two points - if allowed then one of those points is duplicated since a PolygonOnSphere requires at least three points - default is <tt class="docutils literal"><span class="pre">True</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type allow_one_or_two_points:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">bool</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body">InvalidPointsForPolygonConstructionError if <em>geometry</em> is a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a>, or a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a> with one or two points (and <em>allow_one_or_two_points</em> is <tt class="docutils literal"><span class="pre">False</span></tt>), or if any two consecutive points in a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a> are antipodal to each other (on opposite sides of the globe)</td>
</tr>
</tbody>
</table>
<p>If <em>allow_one_or_two_points</em> is <tt class="docutils literal"><span class="pre">True</span></tt> then <em>geometry</em> can be <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a> or <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a>. However if <em>allow_one_or_two_points</em> is <tt class="docutils literal"><span class="pre">False</span></tt> then <em>geometry</em> must be a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a>, or a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a> or <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a> containing at least three points to avoid raising <em>InvalidPointsForPolygonConstructionError</em>.</p>
<p>During creation, a <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">GreatCircleArc</span></tt></a> is created between each adjacent pair of geometry points - see <a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><tt class="xref py py-meth docutils literal"><span class="pre">get_segments()</span></tt></a>.</p>
<p>It is <em>not</em> an error for adjacent points in a geometry sequence to be coincident. In this case each <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">GreatCircleArc</span></tt></a> between two such adjacent points will have zero length (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.is_zero_length" title="pygplates.GreatCircleArc.is_zero_length"><tt class="xref py py-meth docutils literal"><span class="pre">GreatCircleArc.is_zero_length()</span></tt></a> will return <tt class="docutils literal"><span class="pre">True</span></tt>) and will have no rotation axis (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.get_rotation_axis" title="pygplates.GreatCircleArc.get_rotation_axis"><tt class="xref py py-meth docutils literal"><span class="pre">GreatCircleArc.get_rotation_axis()</span></tt></a> will raise an error). However if two such adjacent points are antipodal (on opposite sides of the globe) then InvalidPointsForPolygonConstructionError will be raised</p>
<p>To create a PolygonOnSphere from any geometry type:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
</pre></div>
</div>
<p>To create a PolygonOnSphere from any geometry containing at least three points:</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">allow_one_or_two_points</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="k">except</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">InvalidPointsForPolygonConstructionError</span><span class="p">:</span>
    <span class="o">...</span> <span class="c1"># Handle failure to convert &#39;geometry&#39; to a PolygonOnSphere.</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.__init__" title="pygplates.PolygonOnSphere.__init__"><tt class="xref py py-obj docutils literal"><span class="pre">__init__</span></tt></a>(...)</td>
<td>A <em>PolygonOnSphere</em> object can be constructed in more than one way...</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.clone" title="pygplates.PolygonOnSphere.clone"><tt class="xref py py-obj docutils literal"><span class="pre">clone</span></tt></a>()</td>
<td>Create a duplicate of this geometry (derived) instance.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.distance" title="pygplates.PolygonOnSphere.distance"><tt class="xref py py-obj docutils literal"><span class="pre">distance</span></tt></a>(geometry1,&nbsp;geometry2,&nbsp;...)</td>
<td>[<em>staticmethod</em>] Returns the (minimum) distance between two geometries (in radians).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_arc_length" title="pygplates.PolygonOnSphere.get_arc_length"><tt class="xref py py-obj docutils literal"><span class="pre">get_arc_length</span></tt></a>()</td>
<td>Returns the total arc length of this polygon (in radians).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_area" title="pygplates.PolygonOnSphere.get_area"><tt class="xref py py-obj docutils literal"><span class="pre">get_area</span></tt></a>()</td>
<td>Returns the area of this polygon (on a sphere of unit radius).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_boundary_centroid" title="pygplates.PolygonOnSphere.get_boundary_centroid"><tt class="xref py py-obj docutils literal"><span class="pre">get_boundary_centroid</span></tt></a>()</td>
<td>Returns the <em>boundary</em> centroid of this polygon.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_interior_centroid" title="pygplates.PolygonOnSphere.get_interior_centroid"><tt class="xref py py-obj docutils literal"><span class="pre">get_interior_centroid</span></tt></a>()</td>
<td>Returns the <em>interior</em> centroid of this polygon.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_orientation" title="pygplates.PolygonOnSphere.get_orientation"><tt class="xref py py-obj docutils literal"><span class="pre">get_orientation</span></tt></a>()</td>
<td>Returns whether this polygon is clockwise or counter-clockwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_points" title="pygplates.PolygonOnSphere.get_points"><tt class="xref py py-obj docutils literal"><span class="pre">get_points</span></tt></a>()</td>
<td>Returns a <em>read-only</em> sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">points</span></tt></a> in this geometry.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><tt class="xref py py-obj docutils literal"><span class="pre">get_segments</span></tt></a>()</td>
<td>Returns a <em>read-only</em> sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">segments</span></tt></a> in this polygon.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_signed_area" title="pygplates.PolygonOnSphere.get_signed_area"><tt class="xref py py-obj docutils literal"><span class="pre">get_signed_area</span></tt></a>()</td>
<td>Returns the <em>signed</em> area of this polygon (on a sphere of unit radius).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.is_point_in_polygon" title="pygplates.PolygonOnSphere.is_point_in_polygon"><tt class="xref py py-obj docutils literal"><span class="pre">is_point_in_polygon</span></tt></a>(point)</td>
<td>Determines whether the specified point lies within the interior of this polygon.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.partition" title="pygplates.PolygonOnSphere.partition"><tt class="xref py py-obj docutils literal"><span class="pre">partition</span></tt></a>(geometry,&nbsp;...)</td>
<td>Partition a geometry into optional inside/outside lists of partitioned geometry pieces.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.to_lat_lon_array" title="pygplates.PolygonOnSphere.to_lat_lon_array"><tt class="xref py py-obj docutils literal"><span class="pre">to_lat_lon_array</span></tt></a>()</td>
<td>Returns the sequence of points, in this geometry, as a numpy array of (latitude,longitude) pairs (in degrees).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.to_lat_lon_list" title="pygplates.PolygonOnSphere.to_lat_lon_list"><tt class="xref py py-obj docutils literal"><span class="pre">to_lat_lon_list</span></tt></a>()</td>
<td>Returns the sequence of points, in this geometry, as (latitude,longitude) tuples (in degrees).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.to_lat_lon_point_list" title="pygplates.PolygonOnSphere.to_lat_lon_point_list"><tt class="xref py py-obj docutils literal"><span class="pre">to_lat_lon_point_list</span></tt></a>()</td>
<td>Returns the sequence of points, in this geometry, as <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><tt class="xref py py-class docutils literal"><span class="pre">lat</span> <span class="pre">lon</span> <span class="pre">points</span></tt></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.to_tessellated" title="pygplates.PolygonOnSphere.to_tessellated"><tt class="xref py py-obj docutils literal"><span class="pre">to_tessellated</span></tt></a>(tessellate_radians)</td>
<td>Returns a new polygon that is tessellated version of this polygon.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.to_xyz_array" title="pygplates.PolygonOnSphere.to_xyz_array"><tt class="xref py py-obj docutils literal"><span class="pre">to_xyz_array</span></tt></a>()</td>
<td>Returns the sequence of points, in this geometry, as a numpy array of (x,y,z) triplets.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.to_xyz_list" title="pygplates.PolygonOnSphere.to_xyz_list"><tt class="xref py py-obj docutils literal"><span class="pre">to_xyz_list</span></tt></a>()</td>
<td>Returns the sequence of points, in this geometry, as (x,y,z) cartesian coordinate tuples.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pygplates.PolygonOnSphere.clone">
<tt class="descname">clone</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a duplicate of this geometry (derived) instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">GeometryOnSphere</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.distance">
<tt class="descname">distance</tt><big>(</big><em>geometry1</em>, <em>geometry2</em><span class="optional">[</span>, <em>distance_threshold_radians</em><span class="optional">]</span><span class="optional">[</span>, <em>return_closest_positions=False</em><span class="optional">]</span><span class="optional">[</span>, <em>return_closest_indices=False</em><span class="optional">]</span><span class="optional">[</span>, <em>geometry1_is_solid=False</em><span class="optional">]</span><span class="optional">[</span>, <em>geometry2_is_solid=False</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>[<em>staticmethod</em>] Returns the (minimum) distance between two geometries (in radians).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geometry1</strong> (<a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">GeometryOnSphere</span></tt></a>) &#8211; the first geometry</li>
<li><strong>geometry2</strong> (<a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">GeometryOnSphere</span></tt></a>) &#8211; the second geometry</li>
<li><strong>distance_threshold_radians</strong> (<em>float or None</em>) &#8211; optional distance threshold in radians - threshold should be in the range [0,PI] if specified</li>
<li><strong>return_closest_positions</strong> (<em>bool</em>) &#8211; whether to also return the closest point on each geometry - default is <tt class="docutils literal"><span class="pre">False</span></tt></li>
<li><strong>return_closest_indices</strong> (<em>bool</em>) &#8211; whether to also return the index of the closest <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">point</span></tt></a> (for multi-points) or the index of the closest <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">segment</span></tt></a> (for polylines and polygons) - default is <tt class="docutils literal"><span class="pre">False</span></tt></li>
<li><strong>geometry1_is_solid</strong> (<em>bool</em>) &#8211; whether the interior of <em>geometry1</em> is solid or not - this parameter is ignored if <em>geometry1</em> is not a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a> - default is <tt class="docutils literal"><span class="pre">False</span></tt></li>
<li><strong>geometry2_is_solid</strong> (<em>bool</em>) &#8211; whether the interior of <em>geometry2</em> is solid or not - this parameter is ignored if <em>geometry2</em> is not a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a> - default is <tt class="docutils literal"><span class="pre">False</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">distance (in radians), or a tuple containing distance and the closest point on each geometry if <em>return_closest_positions</em> is <tt class="docutils literal"><span class="pre">True</span></tt>, or a tuple containing distance and the indices of the closest <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">point</span></tt></a> (for multi-points) or <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">segment</span></tt></a> (for polylines and polygons) on each geometry if <em>return_closest_indices</em> is <tt class="docutils literal"><span class="pre">True</span></tt>, or a tuple containing distance and the closest point on each geometry and the indices of the closest <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">point</span></tt></a> (for multi-points) or <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">segment</span></tt></a> (for polylines and polygons) on each geometry if both <em>return_closest_positions</em> and <em>return_closest_indices</em> are <tt class="docutils literal"><span class="pre">True</span></tt>, or <tt class="docutils literal"><span class="pre">None</span></tt> if <em>distance_threshold_radians</em> is specified and exceeded</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float, or tuple (float, <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a>) if <em>return_closest_positions</em> is True, or tuple (float, int, int) if <em>return_closest_indices</em> is True, or tuple (float, <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a>, int, int) if both <em>return_closest_positions</em> and <em>return_closest_indices</em> are True, or None</p>
</td>
</tr>
</tbody>
</table>
<p>The returned distance is the shortest path between <em>geometry1</em> and <em>geometry2</em> along the surface of the sphere (great circle arc path). To convert the distance from radians (distance on a unit radius sphere) to real distance you will need to multiply it by the Earth&#8217;s radius (see <a class="reference internal" href="pygplates.Earth.html#pygplates.Earth" title="pygplates.Earth"><tt class="xref py py-class docutils literal"><span class="pre">Earth</span></tt></a>).</p>
<p>Each geometry (<em>geometry1</em> and <em>geometry2</em>) can be any of the four geometry types (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a> and <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a>) allowing all combinations of distance calculations:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">multi_point2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">polyline2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">polygon2</span><span class="p">)</span>

<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">multi_point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">multi_point1</span><span class="p">,</span> <span class="n">multi_point2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">multi_point1</span><span class="p">,</span> <span class="n">polyline2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">multi_point1</span><span class="p">,</span> <span class="n">polygon2</span><span class="p">)</span>

<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">polyline1</span><span class="p">,</span> <span class="n">point2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">polyline1</span><span class="p">,</span> <span class="n">multi_point2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">polyline1</span><span class="p">,</span> <span class="n">polyline2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">polyline1</span><span class="p">,</span> <span class="n">polygon2</span><span class="p">)</span>

<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">polygon1</span><span class="p">,</span> <span class="n">point2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">polygon1</span><span class="p">,</span> <span class="n">multi_point2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">polygon1</span><span class="p">,</span> <span class="n">polyline2</span><span class="p">)</span>
<span class="n">distance_radians</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">polygon1</span><span class="p">,</span> <span class="n">polygon2</span><span class="p">)</span>
</pre></div>
</div>
<p>If <em>distance_threshold_radians</em> is specified and the (minimum) distance between the two geometries exceeds this threshold then <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Perform a region-of-interest query between two geometries to see if</span>
<span class="c1"># they are within 1 degree of each other.</span>
<span class="c1">#</span>
<span class="c1"># Note that we explicitly test against None because a distance of zero is equilavent to False.</span>
<span class="k">if</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">geometry1</span><span class="p">,</span> <span class="n">geometry2</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Note that it is more efficient to specify a distance threshold parameter (as shown in the above example) than it is to explicitly compare the returned distance to a threshold yourself. This is because internally each polyline/polygon geometry has an inbuilt spatial tree that optimises distance queries.</p>
<p>The minimum distance between two geometries is zero (and hence does not exceed any distance threshold) <strong>if</strong>:</p>
<ul class="simple">
<li>both geometries are a polyline/polygon and they intersect each other, or</li>
<li><em>geometry1_is_solid</em> is <tt class="docutils literal"><span class="pre">True</span></tt> and <em>geometry1</em> is a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a> and <em>geometry2</em> overlaps the interior of the polygon (even if it doesn&#8217;t intersect the polygon boundary) - similarly for <em>geometry2_is_solid</em>. However note that <em>geometry1_is_solid</em> is ignored if <em>geometry1</em> is not a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a> - similarly for <em>geometry2_is_solid</em>.</li>
</ul>
<p>If <em>return_closest_positions</em> is <tt class="docutils literal"><span class="pre">True</span></tt> then the closest point on each geometry is returned (unless the distance threshold is exceeded, if specified). Note that for polygons the closest point is always on the polygon boundary regardless of whether the polygon is solid or not (see <em>geometry1_is_solid</em> and <em>geometry2_is_solid</em>). Also note that the closest position on a polyline/polygon can be anywhere along any of its <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">segments</span></tt></a>. In other words it&#8217;s not the nearest vertex of the polyline/polygon - it&#8217;s the nearest point <em>on</em> the polyline/polygon itself. If both geometries are polyline/polygon and they intersect then the intersection point is returned (same point for both geometries). If both geometries are polyline/polygon and they intersect more than once then any intersection point can be returned (but the same point is returned for both geometries). If one geometry is a solid <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a> and the other geometry is a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a> with more than one of its points inside the interior of the polygon then the closest point in the multi-point could be any of those inside points.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">distance_radians</span><span class="p">,</span> <span class="n">closest_point_on_geometry1</span><span class="p">,</span> <span class="n">closest_point_on_geometry2</span> <span class="o">=</span> \
    <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">geometry1</span><span class="p">,</span> <span class="n">geometry2</span><span class="p">,</span> <span class="n">return_closest_positions</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>If <em>return_closest_indices</em> is <tt class="docutils literal"><span class="pre">True</span></tt> then the index of the closest <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">point</span></tt></a> (for multi-points) or the index of the closest <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">segment</span></tt></a> (for polylines and polygons) is returned (unless the threshold is exceeded, if specified). Note that for <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">point</span></tt></a> geometries the index will always be zero. The point indices can be used to index directly into <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a> and the segment indices can be used with <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere.get_segments" title="pygplates.PolylineOnSphere.get_segments"><tt class="xref py py-meth docutils literal"><span class="pre">PolylineOnSphere.get_segments()</span></tt></a> or <a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><tt class="xref py py-meth docutils literal"><span class="pre">PolygonOnSphere.get_segments()</span></tt></a> as shown in the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">distance_radians</span><span class="p">,</span> <span class="n">closest_point_index_on_multipoint</span><span class="p">,</span> <span class="n">closest_segment_index_on_polyline</span> <span class="o">=</span> \
    <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">multipoint</span><span class="p">,</span> <span class="n">polyline</span><span class="p">,</span> <span class="n">return_closest_indices</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">closest_point_on_multipoint</span> <span class="o">=</span> <span class="n">multipoint</span><span class="p">[</span><span class="n">closest_point_index_on_multipoint</span><span class="p">]</span>
<span class="n">closest_segment_on_polyline</span> <span class="o">=</span> <span class="n">polyline</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()[</span><span class="n">closest_segment_index_on_polyline</span><span class="p">]</span>
<span class="n">closest_segment_normal_vector</span> <span class="o">=</span> <span class="n">closest_segment_on_polyline</span><span class="o">.</span><span class="n">get_great_circle_normal</span><span class="p">()</span>
</pre></div>
</div>
<p>If both <em>return_closest_positions</em> and <em>return_closest_indices</em> are <tt class="docutils literal"><span class="pre">True</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Distance between a polyline and a solid polygon.</span>
<span class="n">distance_radians</span><span class="p">,</span> <span class="n">polyline_point</span><span class="p">,</span> <span class="n">polygon_point</span><span class="p">,</span> <span class="n">polyline_segment_index</span><span class="p">,</span> <span class="n">polygon_segment_index</span> <span class="o">=</span> \
    <span class="n">pygplates</span><span class="o">.</span><span class="n">GeometryOnSphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span>
        <span class="n">polyline</span><span class="p">,</span>
        <span class="n">polygon</span><span class="p">,</span>
        <span class="n">return_closest_positions</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">return_closest_indices</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">geometry2_is_solid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_arc_length">
<tt class="descname">get_arc_length</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.get_arc_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total arc length of this polygon (in radians).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line">This is the sum of the arc lengths of the <a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><tt class="xref py py-meth docutils literal"><span class="pre">segments</span></tt></a> of this polygon.</div>
<div class="line">To convert to distance, multiply the result by the Earth radius (see <a class="reference internal" href="pygplates.Earth.html#pygplates.Earth" title="pygplates.Earth"><tt class="xref py py-class docutils literal"><span class="pre">Earth</span></tt></a>).</div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_area">
<tt class="descname">get_area</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.get_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the area of this polygon (on a sphere of unit radius).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<p>The area is essentially the absolute value of the <a class="reference internal" href="#pygplates.PolygonOnSphere.get_signed_area" title="pygplates.PolygonOnSphere.get_signed_area"><tt class="xref py py-meth docutils literal"><span class="pre">signed</span> <span class="pre">area</span></tt></a>.</p>
<p>To convert to area on the Earth&#8217;s surface, multiply the result by the Earth radius squared (see <a class="reference internal" href="pygplates.Earth.html#pygplates.Earth" title="pygplates.Earth"><tt class="xref py py-class docutils literal"><span class="pre">Earth</span></tt></a>).</p>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_boundary_centroid">
<tt class="descname">get_boundary_centroid</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.get_boundary_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <em>boundary</em> centroid of this polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a></td>
</tr>
</tbody>
</table>
<p>The <em>boundary</em> centroid is calculated as a weighted average of the mid-points of the <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">great</span> <span class="pre">circle</span> <span class="pre">arcs</span></tt></a> of this polygon with weighting proportional to the individual arc lengths.</p>
<p>Note that if you want a centroid closer to the centre-of-mass of the polygon interior then use <a class="reference internal" href="#pygplates.PolygonOnSphere.get_interior_centroid" title="pygplates.PolygonOnSphere.get_interior_centroid"><tt class="xref py py-meth docutils literal"><span class="pre">get_interior_centroid()</span></tt></a> instead.</p>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_interior_centroid">
<tt class="descname">get_interior_centroid</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.get_interior_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <em>interior</em> centroid of this polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a></td>
</tr>
</tbody>
</table>
<p>The <em>interior</em> centroid is calculated as a weighted average of the centroids of spherical triangles formed by the <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">great</span> <span class="pre">circle</span> <span class="pre">arcs</span></tt></a> of this polygon and its (boundary) centroid with weighting proportional to the signed area of each individual spherical triangle. The three vertices of each spherical triangle consist of the polygon (boundary) centroid and the two end points of a great circle arc.</p>
<p>This centroid is useful when the centre-of-mass of the polygon interior is desired. For example, the <em>interior</em> centroid of a bottom-heavy, pear-shaped polygon will be closer to the bottom of the polygon. This centroid is not exactly at the centre-of-mass, but it will be a lot closer to the real centre-of-mass than <a class="reference internal" href="#pygplates.PolygonOnSphere.get_boundary_centroid" title="pygplates.PolygonOnSphere.get_boundary_centroid"><tt class="xref py py-meth docutils literal"><span class="pre">get_boundary_centroid()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_orientation">
<tt class="descname">get_orientation</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.get_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this polygon is clockwise or counter-clockwise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">PolygonOnSphere.Orientation</td>
</tr>
</tbody>
</table>
<p>If this polygon is clockwise (when viewed from above the surface of the sphere) then <em>PolygonOnSphere.Orientation.clockwise</em> is returned, otherwise <em>PolygonOnSphere.Orientation.counter_clockwise</em> is returned.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_orientation</span><span class="p">()</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="o">.</span><span class="n">Orientation</span><span class="o">.</span><span class="n">clockwise</span><span class="p">:</span>
  <span class="k">print</span> <span class="s1">&#39;Orientation is clockwise&#39;</span>
<span class="k">else</span><span class="p">:</span>
  <span class="k">print</span> <span class="s1">&#39;Orientation is counter-clockwise&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_points">
<tt class="descname">get_points</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.get_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <em>read-only</em> sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">points</span></tt></a> in this geometry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">a read-only sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a></td>
</tr>
</tbody>
</table>
<p>The following operations for accessing the points in the returned read-only sequence are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Operation</th>
<th class="head">Result</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">len(seq)</span></tt></td>
<td>length of <em>seq</em></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">seq</span></tt></td>
<td>iterates over the points <em>p</em> of <em>seq</em></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">p</span> <span class="pre">in</span> <span class="pre">seq</span></tt></td>
<td><tt class="docutils literal"><span class="pre">True</span></tt> if <em>p</em> is equal to a point in <em>seq</em></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">p</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">seq</span></tt></td>
<td><tt class="docutils literal"><span class="pre">False</span></tt> if <em>p</em> is equal to a point in <em>seq</em></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">seq[i]</span></tt></td>
<td>the point of <em>seq</em> at index <em>i</em></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">seq[i:j]</span></tt></td>
<td>slice of <em>seq</em> from <em>i</em> to <em>j</em></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">seq[i:j:k]</span></tt></td>
<td>slice of <em>seq</em> from <em>i</em> to <em>j</em> with step <em>k</em></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned sequence is <em>read-only</em> and cannot be modified.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you want a modifiable sequence consider wrapping the returned sequence in a <tt class="docutils literal"><span class="pre">list</span></tt>
using something like <tt class="docutils literal"><span class="pre">points</span> <span class="pre">=</span> <span class="pre">list(geometry.get_points())</span></tt> <strong>but</strong> note that modifying
the <tt class="docutils literal"><span class="pre">list</span></tt> (eg, inserting a new point) will <strong>not</strong> modify the original geometry.</p>
</div>
<p>If this geometry is a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a> then the returned sequence has length one.
For other geometry types (<a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a> and
<a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a>) the length will equal the number of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">points</span></tt></a>
contained within.</p>
<p>The following example demonstrates some uses of the above operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">points</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
<span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">point</span>
<span class="n">first_point</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">last_point</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">However if you know you have a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a> or <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a>
(ie, not a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a>) it&#8217;s actually easier to iterate directly over the geometry itself.</div>
<div class="line">For example with a <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a>:</div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">polyline</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">point</span>
<span class="n">first_point</span> <span class="o">=</span> <span class="n">polyline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">last_point</span> <span class="o">=</span> <span class="n">polyline</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There are also methods that return the sequence of points as (latitude,longitude)
values and (x,y,z) values contained in lists and numpy arrays
(<a class="reference internal" href="#pygplates.PolygonOnSphere.to_lat_lon_list" title="pygplates.PolygonOnSphere.to_lat_lon_list"><tt class="xref py py-meth docutils literal"><span class="pre">to_lat_lon_list()</span></tt></a>, <a class="reference internal" href="#pygplates.PolygonOnSphere.to_lat_lon_array" title="pygplates.PolygonOnSphere.to_lat_lon_array"><tt class="xref py py-meth docutils literal"><span class="pre">to_lat_lon_array()</span></tt></a>, <a class="reference internal" href="#pygplates.PolygonOnSphere.to_xyz_list" title="pygplates.PolygonOnSphere.to_xyz_list"><tt class="xref py py-meth docutils literal"><span class="pre">to_xyz_list()</span></tt></a> and <a class="reference internal" href="#pygplates.PolygonOnSphere.to_xyz_array" title="pygplates.PolygonOnSphere.to_xyz_array"><tt class="xref py py-meth docutils literal"><span class="pre">to_xyz_array()</span></tt></a>).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_segments">
<tt class="descname">get_segments</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.get_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <em>read-only</em> sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">segments</span></tt></a> in this polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">a read-only sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">GreatCircleArc</span></tt></a></td>
</tr>
</tbody>
</table>
<p>The following operations for accessing the great circle arcs in the returned read-only sequence are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Operation</th>
<th class="head">Result</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">len(seq)</span></tt></td>
<td>number of segments of the polygon</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">for</span> <span class="pre">s</span> <span class="pre">in</span> <span class="pre">seq</span></tt></td>
<td>iterates over the segments <em>s</em> of the polygon</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">s</span> <span class="pre">in</span> <span class="pre">seq</span></tt></td>
<td><tt class="docutils literal"><span class="pre">True</span></tt> if <em>s</em> is an segment of the polygon</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">seq</span></tt></td>
<td><tt class="docutils literal"><span class="pre">False</span></tt> if <em>s</em> is an segment of the polygon</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">seq[i]</span></tt></td>
<td>the segment of the polygon at index <em>i</em></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">seq[i:j]</span></tt></td>
<td>slice of segments of the polygon from <em>i</em> to <em>j</em></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">seq[i:j:k]</span></tt></td>
<td>slice of segments of the polygon from <em>i</em> to <em>j</em> with step <em>k</em></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Between each adjacent pair of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">points</span></tt></a> there is an <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">segment</span></tt></a> such that the number of points equals the number of segments.</p>
</div>
<p>The following example demonstrates some uses of the above operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">segments</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
<span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">segment</span><span class="o">.</span><span class="n">is_zero_length</span><span class="p">():</span>
        <span class="n">segment_midpoint_direction</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">get_arc_direction</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">first_segment</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">last_segment</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.get_end_point" title="pygplates.GreatCircleArc.get_end_point"><tt class="xref py py-meth docutils literal"><span class="pre">end</span> <span class="pre">point</span></tt></a> of the last segment is equal to the <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.get_start_point" title="pygplates.GreatCircleArc.get_start_point"><tt class="xref py py-meth docutils literal"><span class="pre">start</span> <span class="pre">point</span></tt></a> of the first segment.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned sequence is <em>read-only</em> and cannot be modified.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you want a modifiable sequence consider wrapping the returned sequence in a <tt class="docutils literal"><span class="pre">list</span></tt> using something like <tt class="docutils literal"><span class="pre">segments</span> <span class="pre">=</span> <span class="pre">list(polygon.get_segments())</span></tt> <strong>but</strong> note that modifying the <tt class="docutils literal"><span class="pre">list</span></tt> (eg, appending a new segment) will <strong>not</strong> modify the original polygon.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_signed_area">
<tt class="descname">get_signed_area</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.get_signed_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <em>signed</em> area of this polygon (on a sphere of unit radius).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<p>If this polygon is clockwise (when viewed from above the surface of the sphere) then the returned area will be negative, otherwise it will be positive. However if you only want to determine the orientation of this polygon then <a class="reference internal" href="#pygplates.PolygonOnSphere.get_orientation" title="pygplates.PolygonOnSphere.get_orientation"><tt class="xref py py-meth docutils literal"><span class="pre">get_orientation()</span></tt></a> is more efficient than comparing the sign of the area.</p>
<p>To convert to <em>signed</em> area on the Earth&#8217;s surface, multiply the result by the Earth radius squared (see <a class="reference internal" href="pygplates.Earth.html#pygplates.Earth" title="pygplates.Earth"><tt class="xref py py-class docutils literal"><span class="pre">Earth</span></tt></a>).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pygplates.PolygonOnSphere.get_area" title="pygplates.PolygonOnSphere.get_area"><tt class="xref py py-meth docutils literal"><span class="pre">get_area()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.is_point_in_polygon">
<tt class="descname">is_point_in_polygon</tt><big>(</big><em>point</em><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.is_point_in_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether the specified point lies within the interior of this polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>point</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><tt class="xref py py-class docutils literal"><span class="pre">LatLonPoint</span></tt></a> or (latitude,longitude), in degrees, or (x,y,z)) &#8211; the point to be tested</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<p>Test if a (latitude, longitude) point is inside a polygon:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_point_in_polygon</span><span class="p">((</span><span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">)):</span>
  <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.partition">
<tt class="descname">partition</tt><big>(</big><em>geometry</em><span class="optional">[</span>, <em>partitioned_geometries_inside</em><span class="optional">]</span><span class="optional">[</span>, <em>partitioned_geometries_outside</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition a geometry into optional inside/outside lists of partitioned geometry pieces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geometry</strong> (<a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">GeometryOnSphere</span></tt></a>) &#8211; the geometry to be partitioned</li>
<li><strong>partitioned_geometries_inside</strong> (<tt class="docutils literal"><span class="pre">list</span></tt> of <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">GeometryOnSphere</span></tt></a>, or None) &#8211; optional list of geometries partitioned <em>inside</em> this polygon (note that the list is <em>not</em> cleared first)</li>
<li><strong>partitioned_geometries_outside</strong> (<tt class="docutils literal"><span class="pre">list</span></tt> of <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">GeometryOnSphere</span></tt></a>, or None) &#8211; optional list of geometries partitioned <em>outside</em> this polygon (note that the list is <em>not</em> cleared first)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">PolygonOnSphere.PartitionResult</p>
</td>
</tr>
</tbody>
</table>
<p>The returned result is:</p>
<ul class="simple">
<li><em>PolygonOnSphere.PartitionResult.inside</em>: if <em>geometry</em> is entirely <em>inside</em> this polygon, or</li>
<li><em>PolygonOnSphere.PartitionResult.outside</em>: if <em>geometry</em> is entirely <em>outside</em> this polygon, or</li>
<li><em>PolygonOnSphere.PartitionResult.intersecting</em>: if <em>geometry</em> <em>intersects</em> this polygon.</li>
</ul>
<p>If <em>partitioned_geometries_inside</em> is specified then it must be a <tt class="docutils literal"><span class="pre">list</span></tt> and any part of <em>geometry</em> inside this polygon is added to it. So if <em>PolygonOnSphere.PartitionResult.inside</em> is returned this means <em>geometry</em> is added and if <em>PolygonOnSphere.PartitionResult.intersecting</em> is returned this means the partitioned parts of <em>geometry</em> inside this polygon are added.</p>
<p>If <em>partitioned_geometries_outside</em> is specified then if must be a <tt class="docutils literal"><span class="pre">list</span></tt> and any part of <em>geometry</em> outside this polygon is added to it. So if <em>PolygonOnSphere.PartitionResult.outside</em> is returned this means <em>geometry</em> is added and if <em>PolygonOnSphere.PartitionResult.intersecting</em> is returned this means the partitioned parts of <em>geometry</em> outside this polygon are added.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Partitioning <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">point</span></tt></a> geometries returns only <em>PolygonOnSphere.PartitionResult.inside</em> or <em>PolygonOnSphere.PartitionResult.outside</em>.</p>
</div>
<p>If a partitioned <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">multi-point</span></tt></a> contains points both inside and outside this polygon then <em>PolygonOnSphere.PartitionResult.intersecting</em> is returned. In this case the points <em>inside</em> are added as a single <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a> to <em>partitioned_geometries_inside</em> (if specified) and the points <em>outside</em> are added as a single <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a> to <em>partitioned_geometries_outside</em> (if specified).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last line-block">
<div class="line">Support for partitioning a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">polygon</span></tt></a> geometry is partial.</div>
<div class="line">If a polygon geometry is entirely inside or entirely outside this polygon then it will get added as a <strong>polygon</strong> as expected (to <em>partitioned_geometries_inside</em> or <em>partitioned_geometries_outside</em> respectively if specified).</div>
<div class="line">But if a polygon geometry intersects this polygon, then partitioned <strong>polylines</strong> (not polygons) are added (to the optional inside/outside lists).</div>
<div class="line">This is also how it is in the Assign Plate IDs dialog in <a class="reference external" href="http://www.gplates.org">GPlates</a>.</div>
<div class="line"><em>In a future release this will be fixed to always return polygons.</em></div>
</div>
</div>
<p>Test if a polyline is entirely inside a polygon:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">polyline</span><span class="p">)</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="o">.</span><span class="n">PartitionResult</span><span class="o">.</span><span class="n">inside</span><span class="p">:</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>Find the bits of a polyline that are outside a group of continental polygons:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Start with the original polyline to partition.</span>
<span class="n">oceanic_polylines</span> <span class="o">=</span> <span class="p">[</span><span class="n">polyline</span><span class="p">]</span>

<span class="k">for</span> <span class="n">continental_polygon</span> <span class="ow">in</span> <span class="n">continental_polygons</span><span class="p">:</span>
    <span class="c1"># Iterate over the polylines that are outside the continental polygons processed so far.</span>
    <span class="n">current_oceanic_polylines</span> <span class="o">=</span> <span class="n">oceanic_polylines</span>
    <span class="c1"># The new list of polylines will also be outside the current continental polygon.</span>
    <span class="n">oceanic_polylines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">current_oceanic_polyline</span> <span class="ow">in</span> <span class="n">current_oceanic_polylines</span><span class="p">:</span>
        <span class="n">continental_polygon</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">current_oceanic_polyline</span><span class="p">,</span> <span class="n">partitioned_geometries_outside</span><span class="o">=</span><span class="n">oceanic_polylines</span><span class="p">)</span>

<span class="c1"># The final result is in &#39;oceanic_polylines&#39;.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.to_lat_lon_array">
<tt class="descname">to_lat_lon_array</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.to_lat_lon_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sequence of points, in this geometry, as a numpy array of (latitude,longitude) pairs (in degrees).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an array of (latitude,longitude) pairs (in degrees)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">2D numpy array with number of points as outer dimension and an inner dimension of two</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method should only be called if the <tt class="docutils literal"><span class="pre">numpy</span></tt> module is available.</p>
</div>
<p>If this geometry is a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a> then the returned sequence has length one.
For other geometry types (<a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a> and
<a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a>) the length will equal the number of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">points</span></tt></a>
contained within.</p>
<p>If you want the latitude/longitude order swapped in the returned tuples then the following is one way to achieve this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Convert (latitude,longitude) to (longitude,latitude).</span>
<span class="n">geometry</span><span class="o">.</span><span class="n">to_lat_lon_array</span><span class="p">()[:,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
</pre></div>
</div>
<p>If you need a flat 1D numpy array then you can do something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">geometry</span><span class="o">.</span><span class="n">to_lat_lon_array</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.to_lat_lon_list">
<tt class="descname">to_lat_lon_list</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.to_lat_lon_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sequence of points, in this geometry, as (latitude,longitude) tuples (in degrees).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of (latitude,longitude) tuples (in degrees)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of (float,float) tuples</td>
</tr>
</tbody>
</table>
<p>If this geometry is a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a> then the returned sequence has length one.
For other geometry types (<a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a> and
<a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a>) the length will equal the number of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">points</span></tt></a>
contained within.</p>
<p>If you want the latitude/longitude order swapped in the returned tuples then the following is one way to achieve this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Convert (latitude,longitude) to (longitude,latitude).</span>
<span class="p">[(</span><span class="n">lon</span><span class="p">,</span><span class="n">lat</span><span class="p">)</span> <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="n">geometry</span><span class="o">.</span><span class="n">to_lat_lon_list</span><span class="p">()]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.to_lat_lon_point_list">
<tt class="descname">to_lat_lon_point_list</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.to_lat_lon_point_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sequence of points, in this geometry, as <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><tt class="xref py py-class docutils literal"><span class="pre">lat</span> <span class="pre">lon</span> <span class="pre">points</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><tt class="xref py py-class docutils literal"><span class="pre">LatLonPoint</span></tt></a></td>
</tr>
</tbody>
</table>
<p>If this geometry is a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a> then the returned sequence has length one.
For other geometry types (<a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a> and
<a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a>) the length will equal the number of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">points</span></tt></a>
contained within.</p>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.to_tessellated">
<tt class="descname">to_tessellated</tt><big>(</big><em>tessellate_radians</em><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.to_tessellated" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new polygon that is tessellated version of this polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tessellate_radians</strong> (<em>float</em>) &#8211; maximum tessellation angle (in radians)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Adjacent points (in the returned tessellated polygon) are separated by no more than <em>tessellate_radians</em> on the globe.</p>
<p>Create a polygon tessellated to 2 degrees:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tessellated_polygon</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">to_tessellated</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since a <em>PolygonOnSphere</em> is immutable it cannot be modified. Which is why a new (tessellated) <em>PolygonOnSphere</em> is returned.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The distance between adjacent points (in the tessellated polygon) will not be exactly <em>uniform</em>. This is because each <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><tt class="xref py py-class docutils literal"><span class="pre">segment</span></tt></a> in the original polygon is tessellated to the nearest integer number of points (that keeps that segment under the threshold) and hence each original <em>segment</em> will have a slightly different tessellation angle.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.to_tessellated" title="pygplates.GreatCircleArc.to_tessellated"><tt class="xref py py-meth docutils literal"><span class="pre">GreatCircleArc.to_tessellated()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.to_xyz_array">
<tt class="descname">to_xyz_array</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.to_xyz_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sequence of points, in this geometry, as a numpy array of (x,y,z) triplets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an array of (x,y,z) triplets</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">2D numpy array with number of points as outer dimension and an inner dimension of three</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method should only be called if the <tt class="docutils literal"><span class="pre">numpy</span></tt> module is available.</p>
</div>
<p>If you need a flat 1D numpy array then you can do something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">geometry</span><span class="o">.</span><span class="n">to_xyz_array</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
</pre></div>
</div>
<p>If this geometry is a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a> then the returned sequence has length one.
For other geometry types (<a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a> and
<a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a>) the length will equal the number of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">points</span></tt></a>
contained within.</p>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.to_xyz_list">
<tt class="descname">to_xyz_list</tt><big>(</big><big>)</big><a class="headerlink" href="#pygplates.PolygonOnSphere.to_xyz_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sequence of points, in this geometry, as (x,y,z) cartesian coordinate tuples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of (x,y,z) tuples</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of (float,float,float) tuples</td>
</tr>
</tbody>
</table>
<p>If this geometry is a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PointOnSphere</span></tt></a> then the returned sequence has length one.
For other geometry types (<a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">MultiPointOnSphere</span></tt></a>, <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolylineOnSphere</span></tt></a> and
<a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">PolygonOnSphere</span></tt></a>) the length will equal the number of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><tt class="xref py py-class docutils literal"><span class="pre">points</span></tt></a>
contained within.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="pygplates.PolylineOnSphere.html"
                        title="previous chapter">pygplates.PolylineOnSphere</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pygplates.GeometryOnSphere.html"
                        title="next chapter">pygplates.GeometryOnSphere</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/generated/pygplates.PolygonOnSphere.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="pygplates.GeometryOnSphere.html" title="pygplates.GeometryOnSphere"
             >next</a> |</li>
        <li class="right" >
          <a href="pygplates.PolylineOnSphere.html" title="pygplates.PolylineOnSphere"
             >previous</a> |</li>
        <li><a href="../index.html">pygplates 2.1.0.18 documentation</a> &raquo;</li>
          <li><a href="../pygplates_reference.html" >Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright (C) 2003-2016 The University of Sydney, Australia
(C) 2004-2016 California Institute of Technology
(C) 2007-2016 The Geological Survey of Norway
.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>